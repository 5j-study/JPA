1차 캐시
- 영속성 컨텍스트는 내부에 캐시를 가직고 있는데 이것을 1차 캐시라 한다.
- 영속성 컨텍스트 내부에 Map이 하나 있는데 키는 @Id로 매핑한 식별자고 값은 엔티티 인스턴스다.
- 1차 캐시의 키는 식별자 값이다.
- em.find()를 호출하면 먼저 1차 캐시에서 엔티티를 찾고 만약 찾는 엔티티가 1차 캐시에 없으면 데이터베이스에서 조회한다.
- 엔티티 인스턴스가 1차 캐시에 있으면 엔티티들을 조회하면 메모리에 있는 1차 캐시에서 바로 불러오므로 성능상 이점을 누릴 수 있다.

동일성 보장
- 영속성 컨텍스트는 성능상 이점과 엔티티의 동일성을 보장한다.
-> 동일성(==) 실제 비교의 값이 같다 , 동등성(equals()) 인스턴스가 가지고 있는 값이 같다.
- JPA는 1차 캐시를 통해 반복 가능한 읽기(REPEATEABLE READ) 등급의 트랜잭션 격리 수준을 데이터베이스가 아닌 애플리케이션 차원에서 제공한다는 장점이 있다.

트랜잭션을 지원하는 쓰기 지연
- 엔티티 매니저는 트랜잭션을 커밋하기 직전까지 데이터베이스에 엔티티를 저장하지 않고 내부 쿼리 저장소에 insert sql을 차곡차곡 모아둔다. 그리고 트랜잭션을 커밋할 때 모아둔 쿼리를 데이터베이스에 보내는데 이것을 트랜잭션을 지원하는 쓰기 지연(transactional write-behind)이라 한다.
- 트랜잭션을 커밋하면 엔티티 매니저는 영속성 컨텍스트를 플러시한다. 플러시는 영속성 컨텍스트의 변경 내용을 데이터베이스에 동기화하는 작업인데 이때 등록, 수정, 삭제한 엔티티를 데이터베이스에 반영한다.
- 이 기능을 잘 활용하면 모아둔 등록 쿼리를 데이터베이스에 한 번에 전달해서 성능을 최적화할 수 있다.

변경 감지
- 엔티티의 변경사항을 데이터베이스에 자동으로 반영하는 기능을 변경 감지(dirty checking)라 한다.
- SQL 수정 쿼리는 요구사항에 따라 계속 변경된다. 비지니스 로직이 SQL에 의존하게 된다.
